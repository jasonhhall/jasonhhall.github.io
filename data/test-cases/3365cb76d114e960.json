{
  "uid" : "3365cb76d114e960",
  "name" : "\"before all\" hook for CASE CATEGORY COMBINATION",
  "fullName" : "CASE CATEGORY COMBINATION.\"before all\" hook for CASE CATEGORY COMBINATION",
  "historyId" : "26a2c14db9d6ad081cbf46691cbb150d",
  "time" : {
    "start" : 1642353584624,
    "stop" : 1642354230733,
    "duration" : 646109
  },
  "description" : "Validate that various combination of category, sub-category and detail-category are available and relevant mandatory fields are displayed",
  "descriptionHtml" : "<p>Validate that various combination of category, sub-category and detail-category are available and relevant mandatory fields are displayed</p>\n",
  "status" : "broken",
  "statusMessage" : "waitUntil condition failed with the following reason: Timeout awaiting 'request' for 100000ms when running \"execute/sync\" with method \"POST\" and args \"function isElementClickable(elem) {\n                    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n                        return false;\n                    }\n                    // Edge before switching to Chromium\n                    const isOldEdge = !!window.StyleMedia;\n                    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n                    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n                    // get overlapping element\n                    function getOverlappingElement(elem, context) {\n                        context = context || document;\n                        const elemDimension = elem.getBoundingClientRect();\n                        const x = elemDimension.left + (elem.clientWidth / 2);\n                        const y = elemDimension.top + (elem.clientHeight / 2);\n                        return context.elementFromPoint(x, y);\n                    }\n                    // get overlapping element rects (currently only the first)\n                    // applicable if element's text is multiline.\n                    function getOverlappingRects(elem, context) {\n                        context = context || document;\n                        const elems = [];\n                        const rects = elem.getClientRects();\n                        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n                        const rect = rects[0];\n                        const x = rect.left + (rect.width / 2);\n                        const y = rect.top + (rect.height / 2);\n                        elems.push(context.elementFromPoint(x, y));\n                        return elems;\n                    }\n                    // get overlapping elements\n                    function getOverlappingElements(elem, context) {\n                        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n                    }\n                    // is a node a descendant of a given node\n                    function nodeContains(elem, otherNode) {\n                        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n                        if (isOldEdge) {\n                            let tmpElement = otherNode;\n                            while (tmpElement) {\n                                if (tmpElement === elem) {\n                                    return true;\n                                }\n                                tmpElement = tmpElement.parentNode;\n                                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                                    tmpElement = tmpElement.host;\n                                }\n                            }\n                            return false;\n                        }\n                        return elem.contains(otherNode);\n                    }\n                    // is one of overlapping elements the `elem` or one of its child\n                    function isOverlappingElementMatch(elementsFromPoint, elem) {\n                        if (elementsFromPoint.some(function (elementFromPoint) {\n                            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n                        })) {\n                            return true;\n                        }\n                        // shadow root\n                        // filter unique elements with shadowRoot\n                        // @ts-ignore\n                        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n                        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n                            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n                        });\n                        // getOverlappingElements of every element with shadowRoot\n                        let shadowElementsFromPoint = [];\n                        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n                            let shadowElement = elemsWithShadowRoot[i];\n                            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n                        }\n                        // remove duplicates and parents\n                        // @ts-ignore\n                        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n                        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n                            return !elementsFromPoint.includes(x);\n                        });\n                        if (shadowElementsFromPoint.length === 0) {\n                            return false;\n                        }\n                        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n                    }\n                    // copied from `isElementInViewport.js`\n                    function isElementInViewport(elem) {\n                        if (!elem.getBoundingClientRect) {\n                            return false;\n                        }\n                        const rect = elem.getBoundingClientRect();\n                        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n                        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n                        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n                        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n                        return (vertInView && horInView);\n                    }\n                    function isClickable(elem) {\n                        return (isElementInViewport(elem) && elem.disabled !== true &&\n                            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n                    }\n                    // scroll to the element if it's not clickable\n                    if (!isClickable(elem)) {\n                        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n                        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n                        // if element is still not clickable take another scroll attempt\n                        if (!isClickable(elem)) {\n                            // scroll to element, try put it in the screen center.\n                            // Should definitely work even if element was covered with sticky header/footer\n                            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n                            return isClickable(elem);\n                        }\n                    }\n                    return true;\n                }\"",
  "statusTrace" : "Error: waitUntil condition failed with the following reason: Timeout awaiting 'request' for 100000ms when running \"execute/sync\" with method \"POST\" and args \"function isElementClickable(elem) {\n                    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n                        return false;\n                    }\n                    // Edge before switching to Chromium\n                    const isOldEdge = !!window.StyleMedia;\n                    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n                    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n                    // get overlapping element\n                    function getOverlappingElement(elem, context) {\n                        context = context || document;\n                        const elemDimension = elem.getBoundingClientRect();\n                        const x = elemDimension.left + (elem.clientWidth / 2);\n                        const y = elemDimension.top + (elem.clientHeight / 2);\n                        return context.elementFromPoint(x, y);\n                    }\n                    // get overlapping element rects (currently only the first)\n                    // applicable if element's text is multiline.\n                    function getOverlappingRects(elem, context) {\n                        context = context || document;\n                        const elems = [];\n                        const rects = elem.getClientRects();\n                        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n                        const rect = rects[0];\n                        const x = rect.left + (rect.width / 2);\n                        const y = rect.top + (rect.height / 2);\n                        elems.push(context.elementFromPoint(x, y));\n                        return elems;\n                    }\n                    // get overlapping elements\n                    function getOverlappingElements(elem, context) {\n                        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n                    }\n                    // is a node a descendant of a given node\n                    function nodeContains(elem, otherNode) {\n                        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n                        if (isOldEdge) {\n                            let tmpElement = otherNode;\n                            while (tmpElement) {\n                                if (tmpElement === elem) {\n                                    return true;\n                                }\n                                tmpElement = tmpElement.parentNode;\n                                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                                    tmpElement = tmpElement.host;\n                                }\n                            }\n                            return false;\n                        }\n                        return elem.contains(otherNode);\n                    }\n                    // is one of overlapping elements the `elem` or one of its child\n                    function isOverlappingElementMatch(elementsFromPoint, elem) {\n                        if (elementsFromPoint.some(function (elementFromPoint) {\n                            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n                        })) {\n                            return true;\n                        }\n                        // shadow root\n                        // filter unique elements with shadowRoot\n                        // @ts-ignore\n                        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n                        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n                            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n                        });\n                        // getOverlappingElements of every element with shadowRoot\n                        let shadowElementsFromPoint = [];\n                        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n                            let shadowElement = elemsWithShadowRoot[i];\n                            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n                        }\n                        // remove duplicates and parents\n                        // @ts-ignore\n                        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n                        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n                            return !elementsFromPoint.includes(x);\n                        });\n                        if (shadowElementsFromPoint.length === 0) {\n                            return false;\n                        }\n                        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n                    }\n                    // copied from `isElementInViewport.js`\n                    function isElementInViewport(elem) {\n                        if (!elem.getBoundingClientRect) {\n                            return false;\n                        }\n                        const rect = elem.getBoundingClientRect();\n                        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n                        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n                        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n                        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n                        return (vertInView && horInView);\n                    }\n                    function isClickable(elem) {\n                        return (isElementInViewport(elem) && elem.disabled !== true &&\n                            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n                    }\n                    // scroll to the element if it's not clickable\n                    if (!isClickable(elem)) {\n                        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n                        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n                        // if element is still not clickable take another scroll attempt\n                        if (!isClickable(elem)) {\n                            // scroll to element, try put it in the screen center.\n                            // Should definitely work even if element was covered with sticky header/footer\n                            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n                            return isClickable(elem);\n                        }\n                    }\n                    return true;\n                }\"\n                    at D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:70:15\n                    at processTicksAndRejections (internal/process/task_queues.js:95:5)\n                    at Element.wrapCommandFn (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n                    at Element.elementErrorHandlerCallbackFn (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n                    at Element.wrapCommandFn (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n                    at Element.wrapCommandFn (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n                    at Element.elementErrorHandlerCallbackFn (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n                    at Element.wrapCommandFn (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n                    at ContactView.clicksExperienceAsUser (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\test\\page\\/contactview.js:31:9)\n                    at Context.<anonymous> (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\test\\specs\\twitch-support\\case-category-combination\\/case-category-combination-03.spec.js:69:21)",
  "flaky" : false,
  "newFailed" : false,
  "beforeStages" : [ ],
  "testStage" : {
    "status" : "broken",
    "statusMessage" : "waitUntil condition failed with the following reason: Timeout awaiting 'request' for 100000ms when running \"execute/sync\" with method \"POST\" and args \"function isElementClickable(elem) {\n                    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n                        return false;\n                    }\n                    // Edge before switching to Chromium\n                    const isOldEdge = !!window.StyleMedia;\n                    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n                    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n                    // get overlapping element\n                    function getOverlappingElement(elem, context) {\n                        context = context || document;\n                        const elemDimension = elem.getBoundingClientRect();\n                        const x = elemDimension.left + (elem.clientWidth / 2);\n                        const y = elemDimension.top + (elem.clientHeight / 2);\n                        return context.elementFromPoint(x, y);\n                    }\n                    // get overlapping element rects (currently only the first)\n                    // applicable if element's text is multiline.\n                    function getOverlappingRects(elem, context) {\n                        context = context || document;\n                        const elems = [];\n                        const rects = elem.getClientRects();\n                        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n                        const rect = rects[0];\n                        const x = rect.left + (rect.width / 2);\n                        const y = rect.top + (rect.height / 2);\n                        elems.push(context.elementFromPoint(x, y));\n                        return elems;\n                    }\n                    // get overlapping elements\n                    function getOverlappingElements(elem, context) {\n                        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n                    }\n                    // is a node a descendant of a given node\n                    function nodeContains(elem, otherNode) {\n                        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n                        if (isOldEdge) {\n                            let tmpElement = otherNode;\n                            while (tmpElement) {\n                                if (tmpElement === elem) {\n                                    return true;\n                                }\n                                tmpElement = tmpElement.parentNode;\n                                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                                    tmpElement = tmpElement.host;\n                                }\n                            }\n                            return false;\n                        }\n                        return elem.contains(otherNode);\n                    }\n                    // is one of overlapping elements the `elem` or one of its child\n                    function isOverlappingElementMatch(elementsFromPoint, elem) {\n                        if (elementsFromPoint.some(function (elementFromPoint) {\n                            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n                        })) {\n                            return true;\n                        }\n                        // shadow root\n                        // filter unique elements with shadowRoot\n                        // @ts-ignore\n                        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n                        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n                            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n                        });\n                        // getOverlappingElements of every element with shadowRoot\n                        let shadowElementsFromPoint = [];\n                        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n                            let shadowElement = elemsWithShadowRoot[i];\n                            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n                        }\n                        // remove duplicates and parents\n                        // @ts-ignore\n                        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n                        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n                            return !elementsFromPoint.includes(x);\n                        });\n                        if (shadowElementsFromPoint.length === 0) {\n                            return false;\n                        }\n                        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n                    }\n                    // copied from `isElementInViewport.js`\n                    function isElementInViewport(elem) {\n                        if (!elem.getBoundingClientRect) {\n                            return false;\n                        }\n                        const rect = elem.getBoundingClientRect();\n                        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n                        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n                        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n                        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n                        return (vertInView && horInView);\n                    }\n                    function isClickable(elem) {\n                        return (isElementInViewport(elem) && elem.disabled !== true &&\n                            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n                    }\n                    // scroll to the element if it's not clickable\n                    if (!isClickable(elem)) {\n                        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n                        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n                        // if element is still not clickable take another scroll attempt\n                        if (!isClickable(elem)) {\n                            // scroll to element, try put it in the screen center.\n                            // Should definitely work even if element was covered with sticky header/footer\n                            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n                            return isClickable(elem);\n                        }\n                    }\n                    return true;\n                }\"",
    "statusTrace" : "Error: waitUntil condition failed with the following reason: Timeout awaiting 'request' for 100000ms when running \"execute/sync\" with method \"POST\" and args \"function isElementClickable(elem) {\n                    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n                        return false;\n                    }\n                    // Edge before switching to Chromium\n                    const isOldEdge = !!window.StyleMedia;\n                    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n                    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n                    // get overlapping element\n                    function getOverlappingElement(elem, context) {\n                        context = context || document;\n                        const elemDimension = elem.getBoundingClientRect();\n                        const x = elemDimension.left + (elem.clientWidth / 2);\n                        const y = elemDimension.top + (elem.clientHeight / 2);\n                        return context.elementFromPoint(x, y);\n                    }\n                    // get overlapping element rects (currently only the first)\n                    // applicable if element's text is multiline.\n                    function getOverlappingRects(elem, context) {\n                        context = context || document;\n                        const elems = [];\n                        const rects = elem.getClientRects();\n                        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n                        const rect = rects[0];\n                        const x = rect.left + (rect.width / 2);\n                        const y = rect.top + (rect.height / 2);\n                        elems.push(context.elementFromPoint(x, y));\n                        return elems;\n                    }\n                    // get overlapping elements\n                    function getOverlappingElements(elem, context) {\n                        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n                    }\n                    // is a node a descendant of a given node\n                    function nodeContains(elem, otherNode) {\n                        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n                        if (isOldEdge) {\n                            let tmpElement = otherNode;\n                            while (tmpElement) {\n                                if (tmpElement === elem) {\n                                    return true;\n                                }\n                                tmpElement = tmpElement.parentNode;\n                                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                                    tmpElement = tmpElement.host;\n                                }\n                            }\n                            return false;\n                        }\n                        return elem.contains(otherNode);\n                    }\n                    // is one of overlapping elements the `elem` or one of its child\n                    function isOverlappingElementMatch(elementsFromPoint, elem) {\n                        if (elementsFromPoint.some(function (elementFromPoint) {\n                            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n                        })) {\n                            return true;\n                        }\n                        // shadow root\n                        // filter unique elements with shadowRoot\n                        // @ts-ignore\n                        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n                        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n                            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n                        });\n                        // getOverlappingElements of every element with shadowRoot\n                        let shadowElementsFromPoint = [];\n                        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n                            let shadowElement = elemsWithShadowRoot[i];\n                            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n                        }\n                        // remove duplicates and parents\n                        // @ts-ignore\n                        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n                        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n                            return !elementsFromPoint.includes(x);\n                        });\n                        if (shadowElementsFromPoint.length === 0) {\n                            return false;\n                        }\n                        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n                    }\n                    // copied from `isElementInViewport.js`\n                    function isElementInViewport(elem) {\n                        if (!elem.getBoundingClientRect) {\n                            return false;\n                        }\n                        const rect = elem.getBoundingClientRect();\n                        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n                        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n                        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n                        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n                        return (vertInView && horInView);\n                    }\n                    function isClickable(elem) {\n                        return (isElementInViewport(elem) && elem.disabled !== true &&\n                            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n                    }\n                    // scroll to the element if it's not clickable\n                    if (!isClickable(elem)) {\n                        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n                        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n                        // if element is still not clickable take another scroll attempt\n                        if (!isClickable(elem)) {\n                            // scroll to element, try put it in the screen center.\n                            // Should definitely work even if element was covered with sticky header/footer\n                            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n                            return isClickable(elem);\n                        }\n                    }\n                    return true;\n                }\"\n                    at D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:70:15\n                    at processTicksAndRejections (internal/process/task_queues.js:95:5)\n                    at Element.wrapCommandFn (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n                    at Element.elementErrorHandlerCallbackFn (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n                    at Element.wrapCommandFn (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n                    at Element.wrapCommandFn (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n                    at Element.elementErrorHandlerCallbackFn (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n                    at Element.wrapCommandFn (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n                    at ContactView.clicksExperienceAsUser (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\test\\page\\/contactview.js:31:9)\n                    at Context.<anonymous> (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\test\\specs\\twitch-support\\case-category-combination\\/case-category-combination-03.spec.js:69:21)",
    "steps" : [ {
      "name" : "Login",
      "time" : {
        "start" : 1642353585276,
        "stop" : 1642353613441,
        "duration" : 28165
      },
      "status" : "passed",
      "steps" : [ {
        "name" : "Navigated to URL: https://twitchsupport--test.lightning.force.com/",
        "time" : {
          "start" : 1642353586385,
          "stop" : 1642353586386,
          "duration" : 1
        },
        "status" : "passed",
        "steps" : [ ],
        "attachments" : [ ],
        "parameters" : [ ],
        "attachmentsCount" : 0,
        "shouldDisplayMessage" : false,
        "hasContent" : false,
        "stepsCount" : 0
      }, {
        "name" : "Entered \"daarindo@justin.tv.twitchsupport.test\" in username textbox",
        "time" : {
          "start" : 1642353588113,
          "stop" : 1642353588113,
          "duration" : 0
        },
        "status" : "passed",
        "steps" : [ ],
        "attachments" : [ ],
        "parameters" : [ ],
        "attachmentsCount" : 0,
        "shouldDisplayMessage" : false,
        "hasContent" : false,
        "stepsCount" : 0
      }, {
        "name" : "Entered \"*******\" in password textbox",
        "time" : {
          "start" : 1642353589143,
          "stop" : 1642353589143,
          "duration" : 0
        },
        "status" : "passed",
        "steps" : [ ],
        "attachments" : [ ],
        "parameters" : [ ],
        "attachmentsCount" : 0,
        "shouldDisplayMessage" : false,
        "hasContent" : false,
        "stepsCount" : 0
      }, {
        "name" : "Clicked on \"Login\" button",
        "time" : {
          "start" : 1642353613360,
          "stop" : 1642353613360,
          "duration" : 0
        },
        "status" : "passed",
        "steps" : [ ],
        "attachments" : [ ],
        "parameters" : [ ],
        "attachmentsCount" : 0,
        "shouldDisplayMessage" : false,
        "hasContent" : false,
        "stepsCount" : 0
      }, {
        "name" : "Closed all open tabs",
        "time" : {
          "start" : 1642353613441,
          "stop" : 1642353613441,
          "duration" : 0
        },
        "status" : "passed",
        "steps" : [ ],
        "attachments" : [ ],
        "parameters" : [ ],
        "attachmentsCount" : 0,
        "shouldDisplayMessage" : false,
        "hasContent" : false,
        "stepsCount" : 0
      } ],
      "attachments" : [ ],
      "parameters" : [ ],
      "attachmentsCount" : 0,
      "shouldDisplayMessage" : false,
      "hasContent" : true,
      "stepsCount" : 5
    }, {
      "name" : "Navigate to contact url",
      "time" : {
        "start" : 1642353613441,
        "stop" : 1642353630535,
        "duration" : 17094
      },
      "status" : "passed",
      "steps" : [ {
        "name" : "Navigated to contact URL: https://twitchsupport--test.lightning.force.com/lightning/r/Contact/0033a00002V4HEeAAN/view",
        "time" : {
          "start" : 1642353630535,
          "stop" : 1642353630535,
          "duration" : 0
        },
        "status" : "passed",
        "steps" : [ ],
        "attachments" : [ ],
        "parameters" : [ ],
        "attachmentsCount" : 0,
        "shouldDisplayMessage" : false,
        "hasContent" : false,
        "stepsCount" : 0
      } ],
      "attachments" : [ ],
      "parameters" : [ ],
      "attachmentsCount" : 0,
      "shouldDisplayMessage" : false,
      "hasContent" : true,
      "stepsCount" : 1
    }, {
      "name" : "Log in to experience as user",
      "time" : {
        "start" : 1642353630535,
        "stop" : 1642354230733,
        "duration" : 600198
      },
      "status" : "broken",
      "statusMessage" : "Error: waitUntil condition failed with the following reason: Timeout awaiting 'request' for 100000ms when running \"execute/sync\" with method \"POST\" and args \"function isElementClickable(elem) {\n                    if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n                        return false;\n                    }\n                    // Edge before switching to Chromium\n                    const isOldEdge = !!window.StyleMedia;\n                    // returns true for Chrome and Firefox and false for Safari, Edge and IE\n                    const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n                    // get overlapping element\n                    function getOverlappingElement(elem, context) {\n                        context = context || document;\n                        const elemDimension = elem.getBoundingClientRect();\n                        const x = elemDimension.left + (elem.clientWidth / 2);\n                        const y = elemDimension.top + (elem.clientHeight / 2);\n                        return context.elementFromPoint(x, y);\n                    }\n                    // get overlapping element rects (currently only the first)\n                    // applicable if element's text is multiline.\n                    function getOverlappingRects(elem, context) {\n                        context = context || document;\n                        const elems = [];\n                        const rects = elem.getClientRects();\n                        // webdriver clicks on center of the first element's rect (line of text), it might change in future\n                        const rect = rects[0];\n                        const x = rect.left + (rect.width / 2);\n                        const y = rect.top + (rect.height / 2);\n                        elems.push(context.elementFromPoint(x, y));\n                        return elems;\n                    }\n                    // get overlapping elements\n                    function getOverlappingElements(elem, context) {\n                        return [getOverlappingElement(elem, context)].concat(getOverlappingRects(elem, context));\n                    }\n                    // is a node a descendant of a given node\n                    function nodeContains(elem, otherNode) {\n                        // Edge doesn't support neither Shadow Dom nor contains if ShadowRoot polyfill is used\n                        if (isOldEdge) {\n                            let tmpElement = otherNode;\n                            while (tmpElement) {\n                                if (tmpElement === elem) {\n                                    return true;\n                                }\n                                tmpElement = tmpElement.parentNode;\n                                // DocumentFragment / ShadowRoot polyfill like ShadyRoot\n                                if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n                                    tmpElement = tmpElement.host;\n                                }\n                            }\n                            return false;\n                        }\n                        return elem.contains(otherNode);\n                    }\n                    // is one of overlapping elements the `elem` or one of its child\n                    function isOverlappingElementMatch(elementsFromPoint, elem) {\n                        if (elementsFromPoint.some(function (elementFromPoint) {\n                            return elementFromPoint === elem || nodeContains(elem, elementFromPoint);\n                        })) {\n                            return true;\n                        }\n                        // shadow root\n                        // filter unique elements with shadowRoot\n                        // @ts-ignore\n                        let elemsWithShadowRoot = [].concat(elementsFromPoint);\n                        elemsWithShadowRoot = elemsWithShadowRoot.filter(function (x) {\n                            return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n                        });\n                        // getOverlappingElements of every element with shadowRoot\n                        let shadowElementsFromPoint = [];\n                        for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n                            let shadowElement = elemsWithShadowRoot[i];\n                            shadowElementsFromPoint = shadowElementsFromPoint.concat(getOverlappingElements(elem, shadowElement.shadowRoot));\n                        }\n                        // remove duplicates and parents\n                        // @ts-ignore\n                        shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n                        shadowElementsFromPoint = shadowElementsFromPoint.filter(function (x) {\n                            return !elementsFromPoint.includes(x);\n                        });\n                        if (shadowElementsFromPoint.length === 0) {\n                            return false;\n                        }\n                        return isOverlappingElementMatch(shadowElementsFromPoint, elem);\n                    }\n                    // copied from `isElementInViewport.js`\n                    function isElementInViewport(elem) {\n                        if (!elem.getBoundingClientRect) {\n                            return false;\n                        }\n                        const rect = elem.getBoundingClientRect();\n                        const windowHeight = (window.innerHeight || document.documentElement.clientHeight);\n                        const windowWidth = (window.innerWidth || document.documentElement.clientWidth);\n                        const vertInView = (rect.top <= windowHeight) && ((rect.top + rect.height) > 0);\n                        const horInView = (rect.left <= windowWidth) && ((rect.left + rect.width) > 0);\n                        return (vertInView && horInView);\n                    }\n                    function isClickable(elem) {\n                        return (isElementInViewport(elem) && elem.disabled !== true &&\n                            isOverlappingElementMatch(getOverlappingElements(elem), elem));\n                    }\n                    // scroll to the element if it's not clickable\n                    if (!isClickable(elem)) {\n                        // works well in dialogs, but the element may be still overlapped by some sticky header/footer\n                        elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'nearest', inline: 'nearest' } : false);\n                        // if element is still not clickable take another scroll attempt\n                        if (!isClickable(elem)) {\n                            // scroll to element, try put it in the screen center.\n                            // Should definitely work even if element was covered with sticky header/footer\n                            elem.scrollIntoView(scrollIntoViewFullSupport ? { block: 'center', inline: 'center' } : true);\n                            return isClickable(elem);\n                        }\n                    }\n                    return true;\n                }\"\n                    at D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\webdriverio\\build\\commands\\browser\\waitUntil.js:70:15\n                    at processTicksAndRejections (internal/process/task_queues.js:95:5)\n                    at Element.wrapCommandFn (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n                    at Element.elementErrorHandlerCallbackFn (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n                    at Element.wrapCommandFn (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n                    at Element.wrapCommandFn (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n                    at Element.elementErrorHandlerCallbackFn (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\webdriverio\\build\\middlewares.js:24:32)\n                    at Element.wrapCommandFn (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\node_modules\\@wdio\\utils\\build\\shim.js:131:29)\n                    at ContactView.clicksExperienceAsUser (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\test\\page\\/contactview.js:31:9)\n                    at Context.<anonymous> (D:\\Users\\hllzmj\\Documents\\Projects\\v2\\EPTQE-Salesforce_CX_QE_Automation\\test\\specs\\twitch-support\\case-category-combination\\/case-category-combination-03.spec.js:69:21)",
      "steps" : [ ],
      "attachments" : [ {
        "uid" : "bf759d958474a2ee",
        "name" : "Console Logs",
        "source" : "bf759d958474a2ee.html",
        "type" : "text/html",
        "size" : 68540
      } ],
      "parameters" : [ ],
      "attachmentsCount" : 1,
      "shouldDisplayMessage" : true,
      "hasContent" : true,
      "stepsCount" : 0
    } ],
    "attachments" : [ ],
    "parameters" : [ ],
    "attachmentsCount" : 1,
    "shouldDisplayMessage" : true,
    "hasContent" : true,
    "stepsCount" : 9
  },
  "afterStages" : [ ],
  "labels" : [ {
    "name" : "framework",
    "value" : "wdio"
  }, {
    "name" : "language",
    "value" : "javascript"
  }, {
    "name" : "thread",
    "value" : "0-11"
  }, {
    "name" : "suite",
    "value" : "CASE CATEGORY COMBINATION"
  }, {
    "name" : "testClass",
    "value" : "CASE CATEGORY COMBINATION"
  }, {
    "name" : "testMethod",
    "value" : "\"before all\" hook for CASE CATEGORY COMBINATION"
  }, {
    "name" : "package",
    "value" : "CASE CATEGORY COMBINATION"
  }, {
    "name" : "resultFormat",
    "value" : "allure1"
  } ],
  "parameters" : [ {
    "name" : "browser",
    "value" : "chrome-97.0.4692.71"
  } ],
  "links" : [ ],
  "hidden" : false,
  "retry" : false,
  "extra" : {
    "severity" : "normal",
    "retries" : [ ],
    "categories" : [ {
      "name" : "Test defects",
      "matchedStatuses" : [ ],
      "flaky" : false
    } ],
    "tags" : [ ]
  },
  "source" : "3365cb76d114e960.json",
  "parameterValues" : [ "chrome-97.0.4692.71" ]
}